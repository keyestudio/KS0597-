## 1. 校园智能节能路灯

这一课，我们利用LED灯模块和光敏电阻传感器制作智能节能路灯模型，探究光控原理，体验科技助力绿色校园。

### 1.1 白色LED模块

LED，即发光二极管的简称，发光二极管可高效地将电能转化为光能，是一种常用的发光器件。

![KS6001](../../img/KS6001.png)



#### 参数

工作电压 ：DC 3.3 ~ 5V

工作电流 ：1.5 mA（峰值2.3mA)

最大功率 ：0.07 W

控制信号 ：数字信号

尺寸 ：32 x 23 x 12mm

定位孔大小 ：直径为 4.8 mm

接口 ：间距2.54 mm，3pin弯针接口



#### 原理

对于这款简单的LED灯模块，可以直接使用主板的高低电平来控制LED的亮灭。

**高电平点亮LED:**

- 当输入信号为高电平（3.3V或5V）时，驱动电路会导通，使LED发光。

**低电平熄灭LED:**

- 当输入信号为低电平（0V）时，驱动电路会截止，切断供电，LED停止发光。



#### 实验代码

```c++
int ledPin = 12;  // 定义变量 ledPin，表示 LED 灯连接在 12 号引脚

void setup() {
  pinMode(ledPin, OUTPUT);  // 将 12 号引脚设置为输出模式
}

void loop() {
  digitalWrite(ledPin, HIGH);  // 点亮 LED 灯
  delay(1000);                 // 延时 1 秒
  digitalWrite(ledPin, LOW);   // 熄灭 LED 灯
  delay(1000);                 // 延时 1 秒
}
```



#### 代码说明

**1. 引脚定义**

``` 
int ledPin = 12;
```

- 定义变量 `ledPin`，表示 LED 灯连接在 GPIO12 引脚。



**2.   初始化设置(setup函数，仅执行一次)**

```c++
pinMode(ledPin, OUTPUT);
```

- 将 `ledPin`（即 GPIO12 引脚）设置为输出模式，用于控制 LED 灯。



**3.  主循环(loop函数)**

```c++
digitalWrite(ledPin, HIGH);
```

- 向 `ledPin` 输出高电平，点亮 LED 灯。

```c++
digitalWrite(ledPin, LOW);
```

- 向 `ledPin` 输出低电平，熄灭 LED 灯。

```c++
delay(1000);
```

- 让程序暂停 1 秒钟，LED 灯保持点亮或熄灭状态。



#### 实验结果

代码上传成功后，你会看到白色LED 灯以 1 秒的间隔闪烁：

- 点亮 1 秒 → 熄灭 1 秒 → 点亮 1 秒 → 熄灭 1 秒 → 循环往复。

![0104](../../img/0104.gif)

---

### 1.2 光敏电阻传感器

光敏电阻是一种用于检测环境光强度的电子元件，通过光敏电阻将光照强度转换为电信号，常用于自动灯光控制、环境监测等场景。

![KS6026](../../img/KS6026.png)



#### 参数

工作电压 : DC 3.3 ~ 5V 

电流 : 20 mA

最大功率 : 0.1 W

工作温度 ：-10°C ~ +50°C

输出信号 : 模拟信号

尺寸 ：32 x 23 x 8mm

定位孔大小：直径为 4.8 mm

接口 ：间距2.54 mm，3pin弯针接口



#### 原理

![0101](../../img/0101.png)

光敏电阻传感器模块的输出是**模拟信号**（连续变化的电压），而ESP32需要通过**ADC**将其转换为**数字信号**，以便程序进行处理。

- **什么是ADC?**

- ADC是一种将模拟信号（连续信号）转换为数字信号（离散信号）的设备。在单片机系统中，ADC的作用是将来自传感器或其他模拟设备的信号转换为单片机能够处理的数字数据。

  ![0102](../../img/0102.png)

**光敏电阻模块的信号输出**

光敏电阻传感器模块通常包含：

- **光敏电阻（光照越强，电阻越小）**
- 分压电路（将电阻变化转换为电压变化）

**分压电路工作原理**：

![0103](../../img/0103.png)

- 输出电压（Vout）取自光敏电阻两端：

  <font face="courier New" color="black" size=5.5>$Vout = VCC ×（\frac {R_{LDR}}{R_1 + R_{LDR}}）$ </font> 

- 光照变化 → R_light变化 → V_out变化：

  - 光照增强 → $R_{LDR}$ ↓ → $V_{out}$ ↓ 
  - 光照减弱 → $R_{LDR}$ ↑ → $V_{out}$ ↑



#### 实验代码

```c++
// 定义光敏电阻传感器连接的模拟引脚
const int lightSensorPin = 34;

void setup() {
  // 初始化串口通信，设置波特率为 115200
  Serial.begin(115200);
}

void loop() {
  // 读取光敏电阻传感器的模拟值（0~4095）
  int sensorValue = analogRead(lightSensorPin);

  // 将模拟值转换为电压值（0~3.3V）
  float voltage = sensorValue * (3.3 / 4095.0);

  // 将读取的值打印到串口监视器
  Serial.print("light intensity value: ");
  Serial.print(sensorValue);
  Serial.print("\t voltage value: ");
  Serial.println(voltage);

  // 延时 500 毫秒，避免数据刷新过快
  delay(500);
}
```



#### 代码说明

**1. 引脚定义**

```c++
const int lightSensorPin = 34;
```

- 定义光敏电阻传感器连接到34号模拟输入引脚

  `const`表示这个值在程序运行期间不会改变

<br>

**2.   初始化设置(setup函数)**

```c++
Serial.begin(115200);
```

- 初始化串口通信，设置波特率为115200

  这个函数只在开发板上电或复位时运行一次

  注意：需要与串口监视器的波特率设置一致

<br>

**3.  主循环(loop函数)**

```c++
void loop() {
  // 读取光敏电阻传感器的模拟值（0~4095）
  int sensorValue = analogRead(lightSensorPin);

  // 将模拟值转换为电压值（0~3.3V）
  float voltage = sensorValue * (3.3 / 4095.0);

  // 将读取的值打印到串口监视器
  Serial.print("light intensity value: ");
  Serial.print(sensorValue);
  Serial.print("\t voltage value: ");
  Serial.println(voltage);

  // 延时 500 毫秒，避免数据刷新过快
  delay(500);
}
```

```c++
int sensorValue = analogRead(lightSensorPin);
```

- `analogRead()` 调用ESP32的ADC，返回光敏电阻模块分压电路的输出电压经ADC转换后的数字值（0~4095）。
- `sensorValue` 是ADC对光敏模块模拟信号的量化结果，数值大小与光照强度成反比（光照越强，值越小）。

```c++
sensorValue * (3.3 / 4095.0)
```

- 将数字值转换为实际的电压值。

- 将 ADC 读取的数字值（`sensorValue`）转换为实际的电压值（`voltage`）公式：

  <font face="courier New" color="black" size=5.5>$voltage = sensorValue ×（\frac {参考电压}{ADC最大数字值}）$ </font> 

  对于我们这款主板：

  - 参考电压 = 3.3V
  - ADC 最大数字值 = 4095

  

```c++
Serial.print("light intensity value: ");
```

- 将字符串 `"light intensity value: "` 发送到串口监视器，输出数据后*不换行*。

  ![0105](../../img/0105.png)

```c++
Serial.print(sensorValue);
```

- 将变量 `sensorValue` 的值发送到串口监视器，输出数据后*不换行*。

  ![0106](../../img/0106.png)

```c++
Serial.print("\t voltage value: ");
```

- 将字符串 `"\t voltage value: "` 发送到串口监视器，输出数据后*不换行*。

  `\t` 是制表符，用于在输出中插入一个空格，对齐数据使输出更整齐易读。
  
  ![0107](../../img/0107.png)
  
   

```c++
Serial.print(voltage);
```

- 将变量 `voltage` 的值发送到串口监视器，输出数据后自动换行，以便下一次输出从新行开始。

  ![0108](../../img/0108.png)



#### 实验结果

代码上传成功后，打开串口监视器，设置波特率为115200。

用手掌捂住光敏电阻传感器，然后慢慢松开手掌，可以看到打印数据：

![0109](../../img/0109.png)

总结：

- 当光照强度增加时，传感器输出的模拟值（0~4095）增大，电压值（0~3.3V）也增大。
- 当光照强度减小时，传感器输出的模拟值和电压值减小。

---

### 1.3 校园智能节能路灯

在前面两小节课程中，我们已经学习了 LED 模块和光敏模块的基本原理与使用方法。现在，让我们将这些知识结合起来，动手制作一个校园智能节能路灯！通过这个项目，我们将实现一个能够根据环境光照强度自动调节灯光的智能系统，既节能环保，又充满科技感。

接下来，我们将一步步完成代码编写和功能调试，最终打造出一个实用的智能路灯原型。让我们一起开启这段充满创意与挑战的旅程吧！

==椴木板实拍图==



#### 流程图

```mermaid
graph TD
    A([开始]) --> B[初始化]
    B --> C[读取光敏电阻值]
    C --> D[串口打印数据]
    D --> E{光照值<br><2000?}
    E -- 是 --> F[点亮LED]
    E -- 否 --> G[熄灭LED]
    F & G --> H[延迟500ms]
    H --> C
```



#### 实验代码

```c++
const int lightSensorPin = 34;  // 光敏电阻传感器引脚
const int ledPin = 12;          // LED 灯引脚
const int threshold = 2000;     // 光照强度阈值

void setup() {
  Serial.begin(115200);
  pinMode(ledPin, OUTPUT);  // 设置 LED 灯引脚为输出模式
}

void loop() {
  int sensorValue = analogRead(lightSensorPin);  // 读取光照强度值

  Serial.printf("light intensity value: %d \t voltage value: %.2f\n", sensorValue, voltage);

  // 根据光照强度控制 LED 灯
  if (sensorValue < threshold) {
    digitalWrite(ledPin, HIGH);  // 点亮 LED 灯
  } else {
    digitalWrite(ledPin, LOW);   // 熄灭 LED 灯
  }

  delay(500);
}
```



#### 代码说明

```c++
Serial.printf("light intensity value: %d \t voltage value: %.2f\n", sensorValue, voltage);
```

- 这是一行基于格式化输出的代码，用于通过串口通信将多个变量的值按照指定格式输出到串口监视器。

- ① `Serial.printf()`

  - 功能：格式化输出函数。
  - 参数：
    - 第一个参数是格式化字符串，用于指定输出的格式。
    - 后面的参数是要输出的变量，与格式化字符串中的占位符一一对应。
  - 返回值：无。
  
  ② 格式化字符串
  
  - `"light intensity value: %d \t voltage value: %.2f\n"`
    - `%d`：占位符，表示输出一个整数（`int` 类型）。
    - `%f`：占位符，表示输出一个浮点数（`float` 类型）。
    - `%.2f`：表示输出的浮点数保留两位小数。
    - `\t`：制表符，用于在输出中插入一个空格（对齐数据）。
    - `\n`：换行符，用于在输出后换行。

```c++
   if (sensorValue < threshold) {
       digitalWrite(ledPin, HIGH);  // 点亮 LED 灯
     } else {
       digitalWrite(ledPin, LOW);   // 熄灭 LED 灯
     }
```

   - 这段代码是一个简单的 条件控制语句，用于根据传感器读取的值（`sensorValue`）与设定的阈值（`threshold`）进行比较，从而控制 LED 灯的亮灭。阈值可以根据实际情况进行更改。
     - 当光照低于阈值，自动点亮LED
     - 当光照高于阈值，自动关闭LED



#### 实验结果

代码上传成功后，当光照低于阈值时点亮路灯；当光照高于阈值时关闭路灯，实现节能的效果。

==动图==

智能节能路灯就制作完成啦，让我们一起用科技点亮绿色校园，为环保贡献一份力量！